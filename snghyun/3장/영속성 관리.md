엔티티 매니저팩토리(매니저를 만드는 공장) 비용이 상당히 큼 -> 한개만 만들어 전체에서 공유함
엔티티 매니저 비용이 거의 들지 않음

엔티티매니저팩토리는 여러 스레들가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다.

### 영속성 컨텍스트란?
- 엔티티를 영구 저장하는 환경이라는 뜻이다.
- `persist()` 는 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다.
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다.
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고 영속성 컨텍스트를 관리할 수 있다.

### 엔티티의 생명주기
- 비영속 : 영속성 컨텍스틀와 전혀 관계가 없는 상태
- 영속 : 영속성 컨텍스트에 저장된 상태
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 : 삭제된 상태
영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 뜻이다.

### 영속성 컨텍스트의 특징
- 영속상태는 식별자 값이 반드시 있어야 한다.(@Id)
- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이를 플러시라 함.

#### 영속성 컨텍스트가 엔티티를 관리할 때의 장점
- 1차 캐시
- 동일성 보장
- 트앤잭션을 비원하는 쓰기 지연
- 변경감지
- 지연 로딩

#### 엔티티 조회
영컨은 내부에 캐시를 갖고 있는데 이를 1차 캐시라 함
영속상태의 엔티티는 모두 이곳에 저장됨
```
// 엔티티를 생성한 상태(비영속)
Member mem = new Member();
mem.setId("member1");
mem.setUserName("회원1");

// 엔티티를 영속
em.persist(mem);
```
1차 캐시에 엔티티를 저장한다. 회원 엔티티는 아직 데이터베이스에 저장되지 않았다.

1차 캐시에 없는 경우 엔티티매니저는 데이터베이스를 조회해서 엔티티를 생성함
그리고 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.

#### 동일성 보장
반복해서 호출하여도 영컨은 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. 
따라서 둘은 같은 인스턴스고 결과는 참임.
따라서 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장함.

#### 쓰기 지연
	엔티티 매니저는 트랜잭션을 커밋하기 직전까지 DB에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둠
	트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보냄